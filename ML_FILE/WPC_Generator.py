# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'design_GetData.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox, QDialog
import pyqtgraph as pg
import pretty_errors
## Python
import datetime
import os
import glob
import csv
import time
import pickle
import pandas as pd
import numpy as np
## WPC
from wpcsys import pywpc

PATH: str = 'data_sensor/'

if os.path.basename(os.getcwd()) != "ML_FILE":
    os.chdir('ML_FILE')

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.setFixedSize(458, 240)
        self.VerticalLayout = QtWidgets.QVBoxLayout(Dialog)
        self.VerticalLayout.setObjectName("VerticalLayout")
        self.FormLayout = QtWidgets.QFormLayout()
        self.FormLayout.setObjectName("FormLayout")
        self.LabelFileName = QtWidgets.QLabel(Dialog)
        self.LabelFileName.setObjectName("LabelFileName")
        self.FormLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.LabelFileName)
        self.ComboBox = QtWidgets.QComboBox(Dialog)
        self.ComboBox.setObjectName("ComboBox")
        self.ListCSV = glob.glob((os.path.join('data_sensor/','*.csv')))
        self.ListCSV = [os.path.basename(x) for x in self.ListCSV]
        self.ComboBox.addItems(self.ListCSV)
        self.ComboBox.setEditable(True)
        self.FormLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.ComboBox)
        self.LabelIP = QtWidgets.QLabel(Dialog)
        self.LabelIP.setObjectName("LabelIP")
        self.FormLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.LabelIP)
        self.LineEditIP = QtWidgets.QLineEdit(Dialog)
        self.LineEditIP.setObjectName("LineEditIP")
        self.FormLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.LineEditIP)
        self.LabelMeasuredTime = QtWidgets.QLabel(Dialog)
        self.LabelMeasuredTime.setObjectName("LabelMeasuredTime")
        self.FormLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.LabelMeasuredTime)
        self.LineEdit = QtWidgets.QLineEdit(Dialog)
        self.LineEdit.setObjectName("LineEdit")
        self.OnlyInt = QtGui.QIntValidator()
        self.LineEdit.setValidator(self.OnlyInt)
        self.FormLayout.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.LineEdit)
        self.LabelIntervalTime = QtWidgets.QLabel(Dialog)
        self.LabelIntervalTime.setObjectName("LabelIntervalTime")
        self.FormLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.LabelIntervalTime)
        self.LineEditSamplingTime = QtWidgets.QLineEdit(Dialog)
        self.LineEditSamplingTime.setObjectName("LineEditSamplingTime")
        self.LineEditSamplingTime.setValidator(self.OnlyInt)
        self.FormLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.LineEditSamplingTime)
        self.VerticalLayout.addLayout(self.FormLayout)
        self.ButtonBoxOkCancel = QtWidgets.QDialogButtonBox(Dialog)
        self.ButtonBoxOkCancel.setOrientation(QtCore.Qt.Horizontal)
        self.ButtonBoxOkCancel.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.ButtonBoxOkCancel.setObjectName("ButtonBoxOkCancel")
        self.LabelNewFile = QtWidgets.QLabel(Dialog)
        self.LabelNewFile.setObjectName("LabelNewFile")
        self.FormLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.LabelNewFile)
        self.CheckBox = QtWidgets.QCheckBox(Dialog)
        self.CheckBox.setObjectName("checkBoxNew")
        self.FormLayout.setWidget(4, QtWidgets.QFormLayout.FieldRole, self.CheckBox)
        self.VerticalLayout.addWidget(self.ButtonBoxOkCancel)        

        self.retranslateUi(Dialog)
        ## The connection with Ok and Cancel button for the Dialog
        self.ButtonBoxOkCancel.accepted.connect(Dialog.accept) 
        self.ButtonBoxOkCancel.rejected.connect(Dialog.reject) 
        QtCore.QMetaObject.connectSlotsByName(Dialog)
    
    ## Get the parameters filled from the Dialog    
    def get_parameters(self):
        FILENAME = self.ComboBox.currentText()
        IPSENSOR = self.LineEditIP.text()
        MEASUREDTIME = int(self.LineEdit.text())
        SAMPLINGTIME = int(self.LineEditSamplingTime.text())
        NEW = self.CheckBox.isChecked()
        print(f"new: {NEW}")
        return FILENAME, IPSENSOR, MEASUREDTIME, SAMPLINGTIME, NEW

    ## Establish the text for the Dialog
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.LabelFileName.setText(_translate("Dialog", "FileName"))
        self.LabelIP.setText(_translate("Dialog", "IP adress"))
        self.LineEditIP.setToolTip(_translate("Dialog", "<html><head/><body><p align=\"center\"><br/></p></body></html>"))
        self.LineEditIP.setText(_translate("Dialog", "192.168.5.38"))
        self.LabelMeasuredTime.setText(_translate("Dialog", "Measured Time (ms)"))
        self.LineEdit.setToolTip(_translate("Dialog", "<html><head/><body><p align=\"center\"><br/></p></body></html>"))
        self.LineEdit.setText(_translate("Dialog", "1000"))
        self.LabelIntervalTime.setText(_translate("Dialog", "Interval Time (ms)"))
        self.LineEditSamplingTime.setToolTip(_translate("Dialog", "<html><head/><body><p align=\"center\"><br/></p></body></html>"))
        self.LineEditSamplingTime.setText(_translate("Dialog", "50"))
        self.LabelNewFile.setText(_translate("Dialog", "New File"))

class Dialog(QDialog, Ui_Dialog):
    def __init__(self, parent = None):
        super(Dialog, self).__init__(parent)
        self.setupUi(self)
        
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(632, 477)
        self.CentralWidget = QtWidgets.QWidget(MainWindow)
        self.CentralWidget.setObjectName("CentralWidget")
        self.VerticalLayout = QtWidgets.QVBoxLayout(self.CentralWidget)
        self.VerticalLayout.setObjectName("VerticalLayout")
        self.HorizontalLayoutInput = QtWidgets.QHBoxLayout()
        self.HorizontalLayoutInput.setObjectName("HorizontalLayoutInput")
        self.LineEditIP = QtWidgets.QLineEdit(self.CentralWidget)
        self.LineEditIP.setObjectName("LineEditIP")
        self.HorizontalLayoutInput.addWidget(self.LineEditIP)
        self.LineEditFILENAME = QtWidgets.QLineEdit(self.CentralWidget)
        self.LineEditFILENAME.setObjectName("LineEditFILENAME")
        self.HorizontalLayoutInput.addWidget(self.LineEditFILENAME)
        self.LineEditMeasuredTime = QtWidgets.QLineEdit(self.CentralWidget)
        self.LineEditMeasuredTime.setObjectName("LineEditMeasuredTime")
        self.HorizontalLayoutInput.addWidget(self.LineEditMeasuredTime)
        self.LineEditSamplingTime = QtWidgets.QLineEdit(self.CentralWidget)
        self.LineEditSamplingTime.setObjectName("LineEditSamplingTime")
        self.HorizontalLayoutInput.addWidget(self.LineEditSamplingTime)
        
        ## the rotation and acceleration buttons are combined in pairs  
        self.VLayoutButtonRollXacc = QtWidgets.QVBoxLayout()
        self.VLayoutButtonRollXacc.setObjectName("VLayoutButtonRollXacc")
        
        self.VLayoutButtonPitchYacc = QtWidgets.QVBoxLayout()    
        self.VLayoutButtonPitchYacc.setObjectName("VLayoutButtonPitchYacc")
        
        self.VLayoutButtonYawZacc = QtWidgets.QVBoxLayout()
        self.VLayoutButtonYawZacc.setObjectName("VLayoutButtonYawZacc")
        
        
        self.RollButton = QtWidgets.QPushButton(self.CentralWidget)
        self.RollButton.setObjectName("RollButton")
        self.VLayoutButtonRollXacc.addWidget(self.RollButton)
        self.RollButton.clicked.connect(lambda : self.connect_button('Roll'))
        
        self.XaccButton = QtWidgets.QPushButton(self.CentralWidget)
        self.XaccButton.setObjectName("XaccButton")
        self.VLayoutButtonRollXacc.addWidget(self.XaccButton)
        self.XaccButton.clicked.connect(lambda : self.connect_button('X_acc'))
        self.HorizontalLayoutInput.addLayout(self.VLayoutButtonRollXacc)
        
        
        self.PitchButton = QtWidgets.QPushButton(self.CentralWidget)
        self.PitchButton.setObjectName("PitchButton")
        self.VLayoutButtonPitchYacc.addWidget(self.PitchButton)
        self.PitchButton.clicked.connect(lambda : self.connect_button('Pitch'))
        
        self.YaccButton = QtWidgets.QPushButton(self.CentralWidget)
        self.YaccButton.setObjectName("YaccButton")
        self.VLayoutButtonPitchYacc.addWidget(self.YaccButton)
        self.YaccButton.clicked.connect(lambda : self.connect_button('Y_acc'))
        self.HorizontalLayoutInput.addLayout(self.VLayoutButtonPitchYacc)
        
        
        self.YawButton = QtWidgets.QPushButton(self.CentralWidget)
        self.YawButton.setObjectName("YawButton")
        self.VLayoutButtonYawZacc.addWidget(self.YawButton)
        self.YawButton.clicked.connect(lambda : self.connect_button('Yaw'))
        
        self.ZaccButton = QtWidgets.QPushButton(self.CentralWidget)
        self.ZaccButton.setObjectName("ZaccButton")
        self.VLayoutButtonYawZacc.addWidget(self.ZaccButton)
        self.ZaccButton.clicked.connect(lambda : self.connect_button('Z_acc'))
        self.HorizontalLayoutInput.addLayout(self.VLayoutButtonYawZacc)
        
        
        self.DeleteButton = QtWidgets.QPushButton(self.CentralWidget)
        self.DeleteButton.setObjectName("DeleteButton")
        self.HorizontalLayoutInput.addWidget(self.DeleteButton)
        self.DeleteButton.clicked.connect(lambda: self.supress_last_measure(self.data))
        
        self.QuitButton = QtWidgets.QPushButton(self.CentralWidget)
        self.QuitButton.setAutoFillBackground(False)
        self.QuitButton.setObjectName("QuitButton")
        self.QuitButton.clicked.connect(lambda: self.save_and_quit(filename = FILENAME, data = self.data, MainWindow = MainWindow))
        self.HorizontalLayoutInput.addWidget(self.QuitButton)
        self.VerticalLayout.addLayout(self.HorizontalLayoutInput)
        
        self.GraphicsViewRot = pg.PlotWidget(self.CentralWidget)
        self.GraphicsViewRot.setBackground('w')
        self.GraphicsViewRot.showGrid(x = True, y = True, alpha = 0.5)
        self.GraphicsViewRot.setObjectName("GraphicsViewRot")
        
        self.GraphicsViewAcc = pg.PlotWidget(self.CentralWidget)
        self.GraphicsViewAcc.setBackground('w')
        self.GraphicsViewAcc.showGrid(x = True, y = True, alpha = 0.5)
        self.GraphicsViewAcc.setObjectName("GraphicsViewAcc")
        
        
        
        self.VerticalLayout.addWidget(self.GraphicsViewRot)
        self.VerticalLayout.addWidget(self.GraphicsViewAcc)
        
        self.ProgressBar = QtWidgets.QProgressBar(self.CentralWidget)
        self.ProgressBar.setProperty("value", 100)
        self.ProgressBar.setObjectName("ProgressBar")
        self.VerticalLayout.addWidget(self.ProgressBar)
        
        self.LineEditType = QtWidgets.QLineEdit(self.CentralWidget)
        self.LineEditType.setObjectName("LineEditType")
        self.HorizontalLayoutInput.addWidget(self.LineEditType)
        
        MainWindow.setCentralWidget(self.CentralWidget)
        self.MenuBar = QtWidgets.QMenuBar(MainWindow)
        self.MenuBar.setGeometry(QtCore.QRect(0, 0, 632, 22))
        self.MenuBar.setObjectName("MenuBar")
        MainWindow.setMenuBar(self.MenuBar)
        self.StatusBar = QtWidgets.QStatusBar(MainWindow)
        self.StatusBar.setObjectName("StatusBar")
        MainWindow.setStatusBar(self.StatusBar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        
        
        self.connection_started = False
        
        self.sampling_time = 50 #ms, defaut value, #interval time of the data
        self.dev = pywpc.WifiDAQE3AH()
        self.read_delay = 0.5 #second
        self.sampling_period_device = 0.003
        self.timeout = 1 #second # 3 seconds by default
        self.data = None
        

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.LineEditIP.setText(_translate("MainWindow", IPSENSOR))
        self.LineEditIP.setReadOnly(True)
        self.LineEditFILENAME.setText(_translate("MainWindow", FILENAME))
        self.LineEditFILENAME.setReadOnly(True)
        self.LineEditMeasuredTime.setText(_translate("MainWindow", f"measured time: {MEASUREDTIME} ms"))
        self.LineEditMeasuredTime.setReadOnly(True)
        self.LineEditSamplingTime.setText(_translate("MainWindow", f"sampled time: {SAMPLINGTIME} ms"))
        self.LineEditSamplingTime.setReadOnly(True)
        self.LineEditType.setText(_translate("MainWindow", f"No detected type"))
        self.LineEditType.setReadOnly(True)
        self.RollButton.setText(_translate("MainWindow", "Roll"))
        self.PitchButton.setText(_translate("MainWindow", "Pitch"))
        self.YawButton.setText(_translate("MainWindow", "Yaw"))
        self.XaccButton.setText(_translate("MainWindow", "X_acc"))
        self.YaccButton.setText(_translate("MainWindow", "Y_acc"))
        self.ZaccButton.setText(_translate("MainWindow", "Z_acc"))
        
        self.DeleteButton.setText(_translate("MainWindow", "Delete Last Measure"))
        self.QuitButton.setText(_translate("MainWindow", "Save and Quit"))
        
        
    def connect_button(self, type):
        if not self.connection_started:
            self.connect()
            self.data = self.create_read(new = NEW, name = FILENAME)        
        
        self.add_measure(data = self.data, type = type, sampling_time = SAMPLINGTIME, measured_time = MEASUREDTIME)
       
    
    #use a list of dict, because calcul are more efficient in time than with a dataframe from pandas
    def csv_to_list_dict(self, path):
        with open(path, mode = 'r') as file:
            reader = csv.DictReader(file)
            list_dict = [row for row in reader] 
        return list_dict
    
    
    def create_read(self, new: bool = True, name: str = 'defaultDF.csv'):
        self.data_columns = ['ID', 'Type', 'Roll', 'Pitch', 'Yaw', 'X_acc', 'Y_acc', 'Z_acc', 'Interval Time', 'Time']
        if new or not os.path.exists(f'{PATH}{name}'):
            data = []
        else:
            data = self.csv_to_list_dict(f"{PATH}{name}")
            
        self.data_last_measure = []
        return data

    def get_max_ID(self, data: list):
        ids = [int(d['ID']) for d in data if 'ID' in d.keys()]
        return max(ids) if ids!=[] else 0
    
    
    def connect(self):
        print(f'{pywpc.PKG_FULL_NAME} - Version {pywpc.__version__}')
        
        self.ip_address = self.LineEditIP.text()
        self.port = 0
        try:
                self.dev.connect(self.ip_address) ## Depend on your device
        except Exception as err:
            pywpc.printGenericError(err)
            ErrorMsgBox = QMessageBox()
            ErrorMsgBox.setIcon(QMessageBox.Information)
            ErrorMsgBox.setText("Error: " + str(err))
            ErrorMsgBox.setWindowTitle("Error")
            ErrorMsgBox.setStandardButtons(QMessageBox.Ok)
            
            ## Show the messagebox
            ErrorMsgBox.exec_()
            return
        self.dev.AHRS_open(self.port, self.timeout)
        self.dev.AHRS_start(self.port, self.timeout)
        self.connection_started = True
    
    
    ## there is two function to add data:
    ## add_measure is to add a set of labelled data
    ## add_row is to add a row of data to the temprary list of same label data
    def add_measure(self, data: list, type: str, sampling_time: float = 50, measured_time: float = 1000):
        
        ## we append the value of the last measure if it exists, 
        ## this method is used to easily suppress last measure if needed (cf. supress_last_measure method)
        if len(self.data_last_measure) > 0:
            data.extend(self.data_last_measure)
            
        self.data_last_measure = []
        
        self.sampling_time = sampling_time
        self.ProgressBar.setMaximum(measured_time)
        
        self.ProgressBar.setStyleSheet("QProgressBar::chunk {background-color: yellow;}")
        
        ##to avoid error if type is not correct
        
        assert type in {'Roll', 'Pitch', 'Yaw', 'X_acc', 'Y_acc', 'Z_acc'}, "Type must be 'Roll', 'Pitch', 'Yaw', 'X_acc', 'Y_acc' or 'Z_acc'"
        if len(data) == 0:
            current_ID = 1
        else:
            current_ID = self.get_max_ID(data) + 1
        
        self.GraphicsViewRot.clear()
        self.GraphicsViewRot.addLegend()
        
        self.GraphicsViewAcc.clear()
        self.GraphicsViewAcc.addLegend()
        
        ##plot the curves for the orientation and acceleration
        self.curve_roll = self.GraphicsViewRot.plot(pen = {'color' : '#8CB9BD', 'width' : 3}, symbol = 'o', symbolPen = 'w', symbolBrush = '#8CB9BD',name = 'Roll')
        self.curve_pitch = self.GraphicsViewRot.plot(pen = {'color' : '#ECB159', 'width' : 3}, symbol = 'o', symbolPen = 'w', symbolBrush = '#ECB159',name = 'Pitch')
        self.curve_yaw = self.GraphicsViewRot.plot(pen = {'color' : '#B67352', 'width' : 3}, symbol = 'o', symbolPen = 'w', symbolBrush = '#B67352',name = 'Yaw')
        
        self.curve_x_acc = self.GraphicsViewAcc.plot(pen = {'color' : '#a70f34', 'width' : 3}, symbol = 'o', symbolPen = 'w', symbolBrush = '#a70f34',name = 'X_acc')
        self.curve_y_acc = self.GraphicsViewAcc.plot(pen = {'color' : '#3d90be', 'width' : 3}, symbol = 'o', symbolPen = 'w', symbolBrush = '#3d90be',name = 'Y_acc')
        self.curve_z_acc = self.GraphicsViewAcc.plot(pen = {'color' : '#7c6ca4', 'width' : 3}, symbol = 'o', symbolPen = 'w', symbolBrush = '#7c6ca4',name = 'Z_acc')
        
        self.time = []
        
        self.yaw = []
        self.roll = []
        self.pitch = []
        self.x_acc = []
        self.y_acc = []
        self.z_acc = []
        ## each time the timer reach a sampling time, we add a row to the data list and we plot the new data
        self.timer = QtCore.QTimer()
        self.timer.setInterval(sampling_time)
        self.timer.timeout.connect(lambda: self.add_row(data, type, current_ID, sampling_time))
        self.timer.start()
        QtCore.QTimer.singleShot(measured_time + sampling_time, self.stop_timer)

    def stop_timer(self):
        self.timer.stop() 
    
    def get_type(self, list):
        unique, counts = np.unique(list, return_counts=True)
        if max(counts) < 5:
            return 'No detected type', 'Black'
        elif max(counts) == 5:
            return unique[np.argmax(counts)], 'Orange'
        elif max(counts) == 6:
            return unique[np.argmax(counts)], 'Yellow'
        else:
            return unique[np.argmax(counts)], 'Green'
        
    def add_row(self, data: list, type: str, current_ID: int, sampling_time: float = 50):
        start_time = 1000*time.time()
        mode = 3 ## 0: Orientation, 1: Acceleration, 3: Orientation + Acceleration
        
        self.AHRS_list = self.dev.AHRS_getEstimate(self.port, mode, self.read_delay)
        self.new_row = {'ID': current_ID, 'Type': type, 'Roll': self.AHRS_list[0], 
                        'Pitch': self.AHRS_list[1], 'Yaw': self.AHRS_list[2], 
                        'X_acc': self.AHRS_list[3], 'Y_acc': self.AHRS_list[4], 'Z_acc': self.AHRS_list[5] ,
                        'Interval Time': sampling_time, 'Time': datetime.datetime.now()}
       
        self.time.append(0 if len(self.time) == 0 else self.time[-1] + sampling_time)
        self.roll.append(self.new_row['Roll'])
        self.pitch.append(self.new_row['Pitch'])
        self.yaw.append(self.new_row['Yaw'])
        self.x_acc.append(self.new_row['X_acc'])
        self.y_acc.append(self.new_row['Y_acc'])
        self.z_acc.append(self.new_row['Z_acc'])
        
        self.ProgressBar.setValue(self.time[-1])
        self.data_last_measure.append(self.new_row)
        
        self.curve_roll.setData(self.time, self.roll)
        self.curve_pitch.setData(self.time, self.pitch)
        self.curve_yaw.setData(self.time, self.yaw)
        self.curve_x_acc.setData(self.time, self.x_acc)
        self.curve_y_acc.setData(self.time, self.y_acc)
        self.curve_z_acc.setData(self.time, self.z_acc)
        
        end_time = 1000*time.time()
        print(f"Time to add row: {end_time - start_time} ms")
        
    def supress_last_measure(self, data: list):
        self.data_last_measure = []
        if data is None:
            return
        else:
            self.GraphicsViewRot.clear()
            self.GraphicsViewAcc.clear()
            
        
        
    def save_and_quit(self, data: list = None, filename: str = 'defaultDF.csv', MainWindow = None):
        
        if not self.connection_started:
            print("No action intended, nothing happened in this session")
            MainWindow.close()
            return
        
        else:
            if len(self.data_last_measure) > 0:
                data.extend(self.data_last_measure)
        
            self.timer.stop()
            self.dev.AHRS_stop(self.port, self.timeout)
            print(f"AHRS_close in port {self.port}")
            self.dev.disconnect()
            MainWindow.close()
            self.dev.close()

            def save_list_dict_to_csv(data: list, filename: str):
                #we had index to the final csv
                for i, item in enumerate(data):
                    item["index"] = i
                    
                keys = data[0].keys()
                with open(f"{PATH}{filename}", 'w', newline='') as csvfile:
                    writer = csv.DictWriter(csvfile, fieldnames=keys)
                    writer.writeheader()
                    writer.writerows(data)

            save_list_dict_to_csv(data, filename=FILENAME)
            if os.path.exists(f"{PATH}{filename}"):
                print(f"{filename} successfully saved")
            else:
                print("An error occured, file not saved")
            
            
def main(): 
    import sys
    app = QtWidgets.QApplication(sys.argv)
    dialog = Dialog()
    if dialog.exec_() == QDialog.Accepted:
        global FILENAME, IPSENSOR, MEASUREDTIME, SAMPLINGTIME, NEW
        FILENAME, IPSENSOR, MEASUREDTIME, SAMPLINGTIME, NEW = dialog.get_parameters()
        MainWindow = QtWidgets.QMainWindow()
        ui = Ui_MainWindow()
        ui.setupUi(MainWindow)
        MainWindow.show()
        sys.exit(app.exec_())

if __name__ == "__main__":
    main()